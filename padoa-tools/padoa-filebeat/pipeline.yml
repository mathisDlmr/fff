description: Pipeline for parsing PostgreSQL logs.
processors:
- set:
    field: event.ingested
    value: '{{_ingest.timestamp}}'
- grok:
    field: message
    ignore_missing: true
    patterns:
    - '^%{DATETIME:postgresql.log.timestamp} (\[%{NUMBER:process.pid:long}(-%{BASE16FLOAT:postgresql.log.core_id:long})?\] (%{IP:ip}\(%{NUMBER:port}\))? %{APPLICATION_NAME:application_name} ((\[%{USERNAME:user.name}\]@\[%{POSTGRESQL_DB_NAME:postgresql.log.database}\]|%{USERNAME:user.name}@%{POSTGRESQL_DB_NAME:postgresql.log.database}) )?)?%{WORD:log.level}:  (?:%{NUMBER:postgresql.log.error.code:long}|%{SPACE})(duration: %{NUMBER:temp.duration:float} ms  %{POSTGRESQL_QUERY_STEP}: (%{SEQUELIZE_COMMENT}(\n| ))?\t?%{POSTGRESQL_QUERY:postgresql.log.query}|: %{GREEDYDATA:message}|%{GREEDYDATA:message})'
    pattern_definitions:
      DATETIME: '[-0-9]+ %{TIME} %{WORD:event.timezone}'
      POSTGRESQL_DB_NAME: '[a-zA-Z0-9_]+[a-zA-Z0-9_\-\$]*'
      POSTGRESQL_QUERY_STEP: '%{WORD:postgresql.log.query_step}(?: <unnamed>| %{WORD:postgresql.log.query_name})?'
      POSTGRESQL_QUERY: '(.|\n)*'
      APPLICATION_NAME: '\[?[^\@]*\]?'
      SEQUELIZE_COMMENT: '/\* (%{SEQUELIZE_COMMMENT_DATA} )+ \*/'
      WORD_COMMENT: '[a-zA-Z0-9\-]+'
      SEQUELIZE_COMMMENT_DATA: '(X-Request-ID %{WORD_COMMENT:X-Request-ID})|(SCOPE %{WORD_COMMENT:scope})|(EVTRULE %{WORD_COMMENT:evtRule})|(JOBID %{WORD_COMMENT:jobId})|(%{WORD_COMMENT} %{WORD_COMMENT})'
- date:
    field: postgresql.log.timestamp
    target_field: '@timestamp'
    formats:
    - yyyy-MM-dd HH:mm:ss.SSS zz
    - yyyy-MM-dd HH:mm:ss zz
- script:
    lang: painless
    source: ctx.event.duration = Math.round(ctx.temp.duration * params.scale)
    params:
      scale: 1000000
    if: ctx.temp?.duration != null
- remove:
    field: temp.duration
    ignore_missing: true
- set:
    field: event.kind
    value: event
- append:
    field: event.category
    value:
      - database
- append:
    field: event.type
    value:
      - info
- append:
    field: event.type
    value:
      - error
    if: "ctx?.postgresql?.log?.error?.code != null && ctx.postgresql.log.error.code >= 02000"
- append:
    field: related.user
    value: "{{user.name}}"
    if: "ctx?.user?.name != null"
- script:
    lang: painless
    source: >
      String query = ctx["postgresql"]["log"]["query"];
      query = /\([0-9]+(, [0-9]+)*\)/.matcher(query).replaceAll('SANITIZED_IDS');
      query = /LIMIT [0-9]+/.matcher(query).replaceAll('LIMIT LIMIT_VALUE');
      query = /IN \([^ ,]+(, [^ ,]+)*\)/.matcher(query).replaceAll('IN (SANITIZED_ARRAY)');
      ctx["postgresql"]["log"]["sanitized_query"] = query;
on_failure:
- set:
    field: error.message
    value: '{{ _ingest.on_failure_message }}'
